// This code is auto-generated by the shader processor.

#[allow(unused_imports)]
use rafx_framework::RafxResult;

#[allow(unused_imports)]
use rafx_framework::{
    DescriptorSetAllocator, DescriptorSetArc, DescriptorSetBindings, DescriptorSetInitializer,
    DescriptorSetWriter, DescriptorSetWriterContext, DynDescriptorSet, ImageViewResource,
    ResourceArc,
};

pub const FP16_SCALE: f32 = 0.0009765625f32;
pub const APERTURE_F_NUMBER: f32 = 0.01f32;
pub const ISO: f32 = 1.0f32;
pub const SHUTTER_SPEED_VALUE: f32 = 1.0f32;
pub const KEY_VALUE: f32 = 0.1150f32;
pub const MANUAL_EXPOSURE: f32 = -16.0f32;
pub const WHITE_POINT_HABLE: f32 = 6.0f32;
pub const WHITE_POINT_HEJL: f32 = 1.0f32;
pub const EXPOSURE_MODE_AUTO: i32 = 1;
pub const EXPOSURE_MODE_MANUAL_SBS: i32 = 2;
pub const EXPOSURE_MODE_MANUAL_SOS: i32 = 3;
pub const EXPOSURE_MODE: i32 = EXPOSURE_MODE_MANUAL_SBS;
pub const SHOULDER_STRENGTH: f32 = 4.0f32;
pub const LINEAR_STRENGTH: f32 = 5.0f32;
pub const LINEAR_ANGLE: f32 = 0.1200f32;
pub const TOE_STRENGTH: f32 = 13.0f32;
pub const TM_STEPHEN_HILL_ACES: i32 = 1;
pub const TM_SIMPLIFIED_LUMA_ACES: i32 = 2;
pub const TM_HEJL2015: i32 = 3;
pub const TM_HABLE: i32 = 4;
pub const TM_FILMIC_ALU: i32 = 5;
pub const TM_LOG_DERIVATIVE: i32 = 6;
pub const TM_VISUALIZE_RGB_MAX: i32 = 7;
pub const TM_VISUALIZE_LUMA: i32 = 8;

#[derive(Copy, Clone, Debug)]
#[repr(C)]
pub struct ConfigStd140 {
    pub tonemapper_type: i32, // +0 (size: 4)
    pub _padding0: [u8; 12],  // +4 (size: 12)
} // 16 bytes

impl Default for ConfigStd140 {
    fn default() -> Self {
        ConfigStd140 {
            tonemapper_type: <i32>::default(),
            _padding0: [u8::default(); 12],
        }
    }
}

pub type ConfigUniform = ConfigStd140;

pub const IN_COLOR_DESCRIPTOR_SET_INDEX: usize = 0;
pub const IN_COLOR_DESCRIPTOR_BINDING_INDEX: usize = 0;
pub const IN_BLUR_DESCRIPTOR_SET_INDEX: usize = 0;
pub const IN_BLUR_DESCRIPTOR_BINDING_INDEX: usize = 1;
pub const SMP_DESCRIPTOR_SET_INDEX: usize = 0;
pub const SMP_DESCRIPTOR_BINDING_INDEX: usize = 2;
pub const CONFIG_DESCRIPTOR_SET_INDEX: usize = 0;
pub const CONFIG_DESCRIPTOR_BINDING_INDEX: usize = 3;

pub struct DescriptorSet0Args<'a> {
    pub in_color: &'a ResourceArc<ImageViewResource>,
    pub in_blur: &'a ResourceArc<ImageViewResource>,
    pub config: &'a ConfigUniform,
}

impl<'a> DescriptorSetInitializer<'a> for DescriptorSet0Args<'a> {
    type Output = DescriptorSet0;

    fn create_dyn_descriptor_set(
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> Self::Output {
        let mut descriptor = DescriptorSet0(descriptor_set);
        descriptor.set_args(args);
        descriptor
    }

    fn create_descriptor_set(
        descriptor_set_allocator: &mut DescriptorSetAllocator,
        descriptor_set: DynDescriptorSet,
        args: Self,
    ) -> RafxResult<DescriptorSetArc> {
        let mut descriptor = Self::create_dyn_descriptor_set(descriptor_set, args);
        descriptor.0.flush(descriptor_set_allocator)?;
        Ok(descriptor.0.descriptor_set().clone())
    }
}

impl<'a> DescriptorSetWriter<'a> for DescriptorSet0Args<'a> {
    fn write_to(
        descriptor_set: &mut DescriptorSetWriterContext,
        args: Self,
    ) {
        descriptor_set.set_image(IN_COLOR_DESCRIPTOR_BINDING_INDEX as u32, args.in_color);
        descriptor_set.set_image(IN_BLUR_DESCRIPTOR_BINDING_INDEX as u32, args.in_blur);
        descriptor_set.set_buffer_data(CONFIG_DESCRIPTOR_BINDING_INDEX as u32, args.config);
    }
}

pub struct DescriptorSet0(pub DynDescriptorSet);

impl DescriptorSet0 {
    pub fn set_args_static(
        descriptor_set: &mut DynDescriptorSet,
        args: DescriptorSet0Args,
    ) {
        descriptor_set.set_image(IN_COLOR_DESCRIPTOR_BINDING_INDEX as u32, args.in_color);
        descriptor_set.set_image(IN_BLUR_DESCRIPTOR_BINDING_INDEX as u32, args.in_blur);
        descriptor_set.set_buffer_data(CONFIG_DESCRIPTOR_BINDING_INDEX as u32, args.config);
    }

    pub fn set_args(
        &mut self,
        args: DescriptorSet0Args,
    ) {
        self.set_in_color(args.in_color);
        self.set_in_blur(args.in_blur);
        self.set_config(args.config);
    }

    pub fn set_in_color(
        &mut self,
        in_color: &ResourceArc<ImageViewResource>,
    ) {
        self.0
            .set_image(IN_COLOR_DESCRIPTOR_BINDING_INDEX as u32, in_color);
    }

    pub fn set_in_blur(
        &mut self,
        in_blur: &ResourceArc<ImageViewResource>,
    ) {
        self.0
            .set_image(IN_BLUR_DESCRIPTOR_BINDING_INDEX as u32, in_blur);
    }

    pub fn set_config(
        &mut self,
        config: &ConfigUniform,
    ) {
        self.0
            .set_buffer_data(CONFIG_DESCRIPTOR_BINDING_INDEX as u32, config);
    }

    pub fn flush(
        &mut self,
        descriptor_set_allocator: &mut DescriptorSetAllocator,
    ) -> RafxResult<()> {
        self.0.flush(descriptor_set_allocator)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_struct_config_std140() {
        assert_eq!(std::mem::size_of::<ConfigStd140>(), 16);
        assert_eq!(std::mem::size_of::<i32>(), 4);
        assert_eq!(std::mem::align_of::<i32>(), 4);
        assert_eq!(memoffset::offset_of!(ConfigStd140, tonemapper_type), 0);
        assert_eq!(std::mem::size_of::<[u8; 12]>(), 12);
        assert_eq!(std::mem::align_of::<[u8; 12]>(), 1);
        assert_eq!(memoffset::offset_of!(ConfigStd140, _padding0), 4);
    }
}
