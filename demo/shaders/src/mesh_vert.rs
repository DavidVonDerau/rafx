// This code is auto-generated by the shader processor.

#[allow(unused_imports)]
use serde::{Deserialize, Serialize};

#[allow(unused_imports)]
use renderer_resources::ash::prelude::VkResult;

#[allow(unused_imports)]
use renderer_resources::{ResourceArc, ImageViewResource, DynDescriptorSet, DescriptorSetAllocator, DescriptorSetInitializer, DescriptorSetArc};

#[derive(Copy, Clone, Debug, Default, Serialize, Deserialize)]
#[repr(C)]
pub struct PerObjectDataStd140 {
    pub model: [[f32; 4]; 4],           // +0 (size: 64)
    pub model_view: [[f32; 4]; 4],      // +64 (size: 64)
    pub model_view_proj: [[f32; 4]; 4], // +128 (size: 64)
} // 192 bytes

pub type PerObjectDataUniform = PerObjectDataStd140;

#[derive(Copy, Clone, Debug, Default, Serialize, Deserialize)]
#[repr(C)]
pub struct PerViewDataVSStd140 {
    pub shadow_map_view_proj: [[f32; 4]; 4], // +0 (size: 64)
    pub shadow_map_light_dir: [f32; 3], // +64 (size: 12)
    pub _padding0: [u8; 4],             // +76 (size: 4)
} // 80 bytes

pub type PerViewDataVSUniform = PerViewDataVSStd140;

pub const PER_VIEW_DATA_DESCRIPTOR_SET_INDEX: usize = 0;
pub const PER_VIEW_DATA_DESCRIPTOR_BINDING_INDEX: usize = 4;
pub const PER_OBJECT_DATA_DESCRIPTOR_SET_INDEX: usize = 2;
pub const PER_OBJECT_DATA_DESCRIPTOR_BINDING_INDEX: usize = 0;

pub struct DescriptorSet0Args<'a> {
    pub per_view_data: &'a PerViewDataVSUniform,
}

impl<'a> DescriptorSetInitializer<'a> for DescriptorSet0Args<'a> {
    type Output = DescriptorSet0;

    fn create_dyn_descriptor_set(descriptor_set: DynDescriptorSet, args: Self) -> Self::Output {
        let mut descriptor = DescriptorSet0(descriptor_set);
        descriptor.set_args(args);
        descriptor
    }

    fn create_descriptor_set(descriptor_set_allocator: &mut DescriptorSetAllocator, descriptor_set: DynDescriptorSet, args: Self) -> VkResult<DescriptorSetArc> {
        let mut descriptor = Self::create_dyn_descriptor_set(descriptor_set, args);
        descriptor.0.flush(descriptor_set_allocator)?;
        Ok(descriptor.0.descriptor_set().clone())
    }
}

pub struct DescriptorSet0(pub DynDescriptorSet);

impl DescriptorSet0 {
    pub fn set_args_static(descriptor_set: &mut DynDescriptorSet, args: DescriptorSet0Args) {
        descriptor_set.set_buffer_data(PER_VIEW_DATA_DESCRIPTOR_BINDING_INDEX as u32, args.per_view_data);
    }

    pub fn set_args(&mut self, args: DescriptorSet0Args) {
        self.set_per_view_data(args.per_view_data);
    }

    pub fn set_per_view_data(&mut self, per_view_data: &PerViewDataVSUniform) {
        self.0.set_buffer_data(PER_VIEW_DATA_DESCRIPTOR_BINDING_INDEX as u32, per_view_data);
    }

    pub fn flush(&mut self, descriptor_set_allocator: &mut DescriptorSetAllocator) -> VkResult<()> {
        self.0.flush(descriptor_set_allocator)
    }
}

pub struct DescriptorSet2Args<'a> {
    pub per_object_data: &'a PerObjectDataUniform,
}

impl<'a> DescriptorSetInitializer<'a> for DescriptorSet2Args<'a> {
    type Output = DescriptorSet2;

    fn create_dyn_descriptor_set(descriptor_set: DynDescriptorSet, args: Self) -> Self::Output {
        let mut descriptor = DescriptorSet2(descriptor_set);
        descriptor.set_args(args);
        descriptor
    }

    fn create_descriptor_set(descriptor_set_allocator: &mut DescriptorSetAllocator, descriptor_set: DynDescriptorSet, args: Self) -> VkResult<DescriptorSetArc> {
        let mut descriptor = Self::create_dyn_descriptor_set(descriptor_set, args);
        descriptor.0.flush(descriptor_set_allocator)?;
        Ok(descriptor.0.descriptor_set().clone())
    }
}

pub struct DescriptorSet2(pub DynDescriptorSet);

impl DescriptorSet2 {
    pub fn set_args_static(descriptor_set: &mut DynDescriptorSet, args: DescriptorSet2Args) {
        descriptor_set.set_buffer_data(PER_OBJECT_DATA_DESCRIPTOR_BINDING_INDEX as u32, args.per_object_data);
    }

    pub fn set_args(&mut self, args: DescriptorSet2Args) {
        self.set_per_object_data(args.per_object_data);
    }

    pub fn set_per_object_data(&mut self, per_object_data: &PerObjectDataUniform) {
        self.0.set_buffer_data(PER_OBJECT_DATA_DESCRIPTOR_BINDING_INDEX as u32, per_object_data);
    }

    pub fn flush(&mut self, descriptor_set_allocator: &mut DescriptorSetAllocator) -> VkResult<()> {
        self.0.flush(descriptor_set_allocator)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn test_struct_per_object_data_std140() {
        assert_eq!(std::mem::size_of::<PerObjectDataStd140>(), 192);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(memoffset::offset_of!(PerObjectDataStd140, model), 0);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(memoffset::offset_of!(PerObjectDataStd140, model_view), 64);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(memoffset::offset_of!(PerObjectDataStd140, model_view_proj), 128);
    }

    #[test]
    fn test_struct_per_view_data_vs_std140() {
        assert_eq!(std::mem::size_of::<PerViewDataVSStd140>(), 80);
        assert_eq!(std::mem::size_of::<[[f32; 4]; 4]>(), 64);
        assert_eq!(std::mem::align_of::<[[f32; 4]; 4]>(), 4);
        assert_eq!(memoffset::offset_of!(PerViewDataVSStd140, shadow_map_view_proj), 0);
        assert_eq!(std::mem::size_of::<[f32; 3]>(), 12);
        assert_eq!(std::mem::align_of::<[f32; 3]>(), 4);
        assert_eq!(memoffset::offset_of!(PerViewDataVSStd140, shadow_map_light_dir), 64);
        assert_eq!(std::mem::size_of::<[u8; 4]>(), 4);
        assert_eq!(std::mem::align_of::<[u8; 4]>(), 1);
        assert_eq!(memoffset::offset_of!(PerViewDataVSStd140, _padding0), 76);
    }
}
